# Класс Mat

В Python для работы с изображениями OpenCV использует матрицы NumPy. В C++ контейнером для хранения изображения служит `Mat`, который представляет собой базовый класс с двумя частями данных: 
- заголовок матрицы (matrix header), который содержит такую информацию, как размер матрицы (size), метод хранения матрицы, адрес хранения матрицы и тд.;
- указатель на матрицу.

Размер заголовка матрицы является константным, а размер самой матрицы может варьироваться от изображения к изображению.

Во избежание лишних копирований в процессе обработки изображений OpenCV использует систему подсчета ссылок (reference counting system). Идея состоит в том, что каждый объект `Mat` имеет свой собственный заголовок, однако матрица может быть обобщена между двумя объектами `Mat`, если их указатели матрицы указывают на один и тот же адрес. Более того, операторы копирования будут копировать только заголовки и указатель на матрицу пикселей, а не сами данные.

```cpp
Mat A, C;                          // создаются только заголовки

// here we'll know the method used (allocate matrix)
A = imread(argv[1], IMREAD_COLOR); 
Mat B(A);                          // Use the copy constructor
C = A;                             // Assignment operator
```

Все созданные объекты (`A`, `B`, `C`), в конечном итоге, указывают на одну и ту же матрицу данных, и внесение изменений с использованием любого из них повлияет и на все остальные.

Самое интересное заключается в том, что вы можете создавать заголовки, которые относятся только к части матрицы пикселей. Например, чтобы создать объект, относящийся к интересуемой области изображения (region of interest - ROI), вы просто создаете новый заголовок с новыми границами:

```cpp
Mat D (A, Rect(10, 10, 100, 100) );  // using a rectangle
Mat E = A(Range::all(), Range(1,3)); // using row and column boundaries
```

Система подсчета ссылок отслеживает, сколько объектов используют данную матрицу пикселей, и освобождает память тогда, когда больше нет объектов, использующих эту матрицу. 

Для того, чтобы непосредственно сделать копию матрицы, можно воспользоваться функциями [`cv::Mat::clone()`](https://docs.opencv.org/3.4/d3/d63/classcv_1_1Mat.html#a03d2a2570d06dcae378f788725789aa4) and [`cv::Mat::copyTo()`](https://docs.opencv.org/3.4/d3/d63/classcv_1_1Mat.html#a33fd5d125b4c302b0c9aa86980791a77):

```cpp
Mat F = A.clone();
Mat G;
A.copyTo(G);
```

После созданий копий, изменение `F` или `G` уже не будет влиятьс на матрицу, на которую указывает заголовок объекта `A`.

Всегда следует иметь в виду следующее:

- Аллокация выходного изображения для функций OpenCV происходит автоматически (если не указано иное).
- Вам не нужно думать об управлении памятью с помощью интерфейса OpenCV C++.
- Оператор присваивания и конструктор копирования копируют только заголовок.
- Базовую матрицу изображения можно скопировать с помощью функций `cv::Mat::clone()` и `cv::Mat::copyTo()`.

## Вывод на печать матрицы 

Для того, чтобы посомтреть значения матрицы пикселей объекта класса `Mat`, можно воспользоваться оператором `<<`. Это, однако, работает только для двумерных матриц.

>Различные варианты форматирования вывода представлены в разделе Output formattin на [этой](https://docs.opencv.org/3.4/d6/d6d/tutorial_mat_the_basic_image_container.html) странице.

## Создание объекта `Mat`

### Конструктор

Для создания объекта класса `Mat` можно воспользоваться конструктором класса:

```cpp
Mat M(2,2, CV_8UC3, Scalar(0,0,255));
cout << "M = " << endl << " " << M << endl << endl;
```

В данном случае мы создали двумерное, многоканальное изображение. Сначала мы определили размер изображения первыми двумя аргументами. Третьим аргументом (`CV_8UC3`) мы указали тип данных и число каналов на одну точку пикселя:
- `8U` – тип данных usigned char;
- `C3` – три канала.
Последним аргументом мы задали значения для каналов.

>Также можно использовать функцию [create()](https://docs.opencv.org/3.4/d3/d63/classcv_1_1Mat.html#a55ced2c8d844d683ea9a725c60037ad0).


### `zeros()`, `ones()`, `eye()`

Подобно тому, как это делается в NumPy, можно создать объекти `Mat` используя функции [cv::Mat::zeros](https://docs.opencv.org/3.4/d3/d63/classcv_1_1Mat.html#a56daa006391a670e9cb0cd08e3168c99) , [cv::Mat::ones](https://docs.opencv.org/3.4/d3/d63/classcv_1_1Mat.html#a5e10227b777425407986727e2d26fcdc) , [cv::Mat::eye](https://docs.opencv.org/3.4/d3/d63/classcv_1_1Mat.html#a458874f0ab8946136254da37ba06b78b)

```cpp
Mat E = Mat::eye(4, 4, CV_64F);
Mat O = Mat::ones(2, 2, CV_32F);
Mat Z = Mat::zeros(3,3, CV_8UC1);
```

### Заполнение случайными значениями

Для этого можно воспользоваться функцией [randu()](https://docs.opencv.org/3.4/d2/de8/group__core__array.html#ga1ba1026dca0807b27057ba6a49d258c0):

```cpp
Mat R = Mat(3, 2, CV_8UC3);
randu(R, Scalar::all(0), Scalar::all(255));
```

### Явное задание значений

Для маленьких матриц можно использовать иницаилизацию значений через запятую:

```cpp
Mat C = (Mat_<double>(3,3) << 0, -1, 0, -1, 5, -1, 0, -1, 0);

C = (Mat_<double>({0, -1, 0, -1, 5, -1, 0, -1, 0})).reshape(3);
```

### Извлечение строки матрицы

Получив доступ к строке матрицы, при помощи метода `row()`, можно затем скопировать ее в новый объект, используя метод `clone()` или `copyTo()`:

```cpp
Mat RowClone = C.row(1).clone();
```

# Обход матрицы (Scanning) 

Послдовательность значений интенсивностей каналов пикселей может храниться в непрерывной области памяти, образуя одну длинную строку (row). В таких случаях можно ускорить процесс обхода. Для того, чтобы проверить, хранится ли матрица в непрерывной области памяти, можно воспользоваться функцией [`cv::Mat::isContinuouts()`](https://docs.opencv.org/3.4/d3/d63/classcv_1_1Mat.html#aa90cea495029c7d1ee0a41361ccecdf3). Когда дело доходит до производительности, вы не можете превзойти классический доступ в стиле C ( `ptr[i]`). Такой эффективный способ представлен [здесь](https://docs.opencv.org/3.4/db/da5/tutorial_how_to_scan_images.html) в разделе The efficient way. Также в разделе On-the-fly address calculation with reference returning описан еще один способ обхода.

## Использование итераторов

Рссмотрим более простой и надежный итеративый способ. Нужно получить `begin` и `end` матрицы изображения, и затем использовать итератор `begin` до достижения `end`.

Предположим, у вас есть LUT, и мы хотим трансформировать им изображение. 

```cpp
uchar table[256];
for (int i = 0; i < 256; ++i)
    table[i] = (uchar)(24 * (i/24));
```

Воспользуемся итератоором чтения-записи шаблоном [`MatIterator_`](https://docs.opencv.org/4.x/d4/dfe/classcv_1_1MatIterator__.html). Для получения значения, на которое указывает итератор `it`, производится разыменование оператором `*`. В случае цветных изображений у нас есть по три элемента `uchar` в каждой позиции. Это можно рассматривать как короткий вектор элементов `uchar`, получивший в OpenCV имя `Vec3b`. Для доступа к `n`-му каналу мы используем оператор `[]`.

```cpp
Mat& ScanImageAndReduceIterator(Mat& I, const uchar* const table)
{
    // accept only char type matrices
    CV_Assert(I.depth() == CV_8U);
    const int channels = I.channels();
    switch(channels)
    {
    case 1:
        {
            MatIterator_<uchar> it, end;
            for( it = I.begin<uchar>(), end = I.end<uchar>(); it != end; ++it)
                *it = table[*it];
            break;
        }
    case 3:
        {
            MatIterator_<Vec3b> it, end;
            for( it = I.begin<Vec3b>(), end = I.end<Vec3b>(); it != end; ++it)
            {
                (*it)[0] = table[(*it)[0]];
                (*it)[1] = table[(*it)[1]];
                (*it)[2] = table[(*it)[2]];
            }
        }
    }
    return I;
}
```

## Использование метода `at()`

Данный способ предпочтительней, когда мы хоти получить доступ к некоторому случайному набору элементов изображения, так как для доступа указываются номера строки и колонки пикселя. Для одноканального изображения используется метод `at()`, а для трехканального изображения используется шаблонный класс матрицы [`Mat_`](https://docs.opencv.org/3.4/df/dfc/classcv_1_1Mat__.html):

```cpp
Mat& ScanImageAndReduceRandomAccess(Mat& I, const uchar* const table)
{
    // accept only char type matrices
    CV_Assert(I.depth() == CV_8U);
    const int channels = I.channels();
    switch(channels)
    {
    case 1:
        {
            for( int i = 0; i < I.rows; ++i)
                for( int j = 0; j < I.cols; ++j )
                    I.at<uchar>(i,j) = table[I.at<uchar>(i,j)];
            break;
        }
    case 3:
        {
         Mat_<Vec3b> _I = I;
         for( int i = 0; i < I.rows; ++i)
            for( int j = 0; j < I.cols; ++j )
               {
                   _I(i,j)[0] = table[_I(i,j)[0]];
                   _I(i,j)[1] = table[_I(i,j)[1]];
                   _I(i,j)[2] = table[_I(i,j)[2]];
            }
         I = _I;
         break;
        }
    }
    return I;
}
```

Этот способ чуть менее производителен, но более гибкий.


# Встроенная функция `LUT()`

При обработке изображений довольно часто возникает необходимость изменить все значения данного изображения на какое-либо другое значение. OpenCV предоставляет функцию для изменения значений изображения без необходимости писать логику сканирования изображения. Для этого можно использовать функцию `cv::LUT()` основного модуля. 

Сначала мы строим таблицу типа `Mat`:

```cpp
Mat lookUpTable(1, 256, CV_8U);
uchar* p = lookUpTable.ptr();
for( int i = 0; i < 256; ++i)
    p[i] = table[i];
```

Далее вызывается функция [`LUT()`](https://docs.opencv.org/3.4/d2/de8/group__core__array.html#gab55b8d062b7f5587720ede032d34156f), где `I` – входное изображение, а `J` – выходное:

```cpp
LUT(I, lookUpTable, J);
```

Для преобразований LUT, проще и эффективней всего будет преобразование функцией `LUT()`. К тому же OpenCV может делать это в многопоточном режиме. 
